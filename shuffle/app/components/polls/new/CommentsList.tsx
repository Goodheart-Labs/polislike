"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import type { useForm } from "react-hook-form";

import { MinusCircleIcon, PlusCircleIcon } from "@heroicons/react/20/solid";
import axios from "axios";
import clsx from "clsx";
import { pullAllBy, set, values } from "lodash/fp";
import { v4 } from "uuid";

import ControlledInput from "@/components/ui/ControlledInput";
import LoadingText from "@/components/ui/LoadingText";

// Config
// -----------------------------------------------------------------------------

const MIN_COMMENTS = 5;
const AUTOGENERATE_AMOUNT = 10;

// Types
// -----------------------------------------------------------------------------

type FormErrors = ReturnType<
  typeof useForm<{
    comments: string[];
  }>
>["formState"]["errors"];

type CommentsListProps = {
  data: {
    title: string;
    question: string;
  };
  state: {
    errors: FormErrors;
  };
  callbacks: {
    onCommentsChange: (comments: string[]) => void;
    onCommentsBlur: (comments: string[]) => void;
  };
};

type CommentsListViewProps = {
  state: {
    comments: Comment[];
    errors: FormErrors;
    canAutogenerate: boolean;
    isAutogenerating: boolean;
    hasAutogenerated: boolean;
    autogeneratingError: string | null;
  };
  callbacks: {
    onClickAddComment: () => void;
    onClickRemoveComment: (key: string) => void;
    onClickAutogenerate: () => void;
    onChangeComment: (key: string, comment: string) => void;
    onBlurComment: (key: string, comment: string) => void;
  };
};

type Comment = { key: string; comment: string };

// View
// -----------------------------------------------------------------------------

const CommentsListView = ({
  state: {
    comments,
    errors,
    canAutogenerate,
    isAutogenerating,
    hasAutogenerated,
    autogeneratingError,
  },
  callbacks: {
    onClickAddComment,
    onClickRemoveComment,
    onClickAutogenerate,
    onChangeComment,
    onBlurComment,
  },
}: CommentsListViewProps) => (
  <div className="flex flex-col">
    <div className="mb-4">
      {canAutogenerate ? (
        <a
          href="#"
          className={clsx(
            "font-semibold underline hover:no-underline",
            isAutogenerating && "cursor-wait no-underline",
          )}
          onClick={(e) => {
            e.preventDefault();
            if (isAutogenerating) return;
            onClickAutogenerate();
          }}
          aria-disabled={isAutogenerating}
        >
          {isAutogenerating ? (
            <LoadingText>
              Autogenerating {AUTOGENERATE_AMOUNT} comments
            </LoadingText>
          ) : (
            `Autogenerate ${AUTOGENERATE_AMOUNT}${
              hasAutogenerated ? " more" : ""
            } comments`
          )}
        </a>
      ) : null}

      {autogeneratingError ? (
        <>
          {" "}
          <span className="mx-2">&middot;</span>
          <span className="text-red-800">
            Something went wrong while autogenerating comments. Please try
            again.
          </span>
        </>
      ) : null}
    </div>

    {comments.map(({ comment }) => comment).filter(Boolean).length <
    MIN_COMMENTS ? (
      <span className="mb-4 text-sm text-red-500">
        You need at least 5 comments
      </span>
    ) : null}

    {comments.map(({ key, comment }, i) => (
      <div key={key} className="flex flex-col">
        <div className="flex items-center justify-between mb-4">
          <div className="w-full">
            <ControlledInput
              className="w-full text-lg"
              value={comment}
              onChange={(val) => onChangeComment(key, val)}
              onBlur={(val) => onBlurComment(key, val.target.value)}
            />
          </div>

          {comments.length > MIN_COMMENTS ? (
            <div className="w-fit">
              <a
                className="w-10 text-red-900 hover:text-red-500"
                href="#"
                onClick={(e) => {
                  e.preventDefault();
                  onClickRemoveComment(key);
                }}
              >
                <MinusCircleIcon className="w-6 ml-2" />
              </a>
            </div>
          ) : null}
        </div>

        {errors?.comments && errors?.comments[i] ? (
          <span className="mt-1 text-sm text-red-500">
            {/* Using the any type here because I'm not sure how to type this */}
            {(errors?.comments as any)[i].message}
          </span>
        ) : null}
      </div>
    ))}

    <div className="flex justify-start w-full mb-20">
      <a
        href="#"
        onClick={(e) => {
          e.preventDefault();
          onClickAddComment();
        }}
        className="flex items-center justify-between text-green-700 hover:text-green-500"
      >
        <PlusCircleIcon className="w-6 mr-1" /> Add Comment
      </a>
    </div>
  </div>
);

// Utils
// -----------------------------------------------------------------------------

const newComment = (comment: string): Comment => ({
  key: v4(),
  comment,
});

const defaultComments = new Array(MIN_COMMENTS)
  .fill(null)
  .map(() => newComment(""));

// Default export
// -----------------------------------------------------------------------------

const CommentsList = ({
  data: { title, question },
  state: { errors },
  callbacks: { onCommentsChange, onCommentsBlur },
}: CommentsListProps) => {
  // State

  const [comments, setComments] = useState<Comment[]>(defaultComments);
  const [isAutogenerating, setIsAutogenerating] = useState(false);
  const [hasAutogenerated, setHasAutogenerated] = useState(false);
  const [autogeneratingError, setAutogeneratingError] = useState<string | null>(
    null,
  );

  // Callbacks

  const onClickAddComment = useCallback(
    () => setComments((comments) => comments.concat(newComment(""))),
    [],
  );

  const onClickRemoveComment = useCallback(
    (key: string) => {
      if (comments.length < MIN_COMMENTS) return;
      setComments((comments) => pullAllBy("key", [{ key }], comments));
    },
    [comments.length],
  );

  const onClickAutogenerate = useCallback(async () => {
    setIsAutogenerating(true);
    setAutogeneratingError(null);

    let autogeneratedComments: string[] = [];

    try {
      const { data } = await axios.post("/api/completions", {
        title,
        question,
      });
      autogeneratedComments = data;
    } catch (e) {
      setAutogeneratingError(
        "Something went wrong while autogenerating comments. Please try again.",
      );
      setIsAutogenerating(false);

      return;
    }

    // TODO: unit tests

    setComments((comments) => {
      const autogeneratedCommentsWithKeys =
        autogeneratedComments.map(newComment);

      const commentsValues = values(comments);

      if (commentsValues.some(({ comment }) => comment.trim() === "")) {
        let newComments = comments;

        // Take two counters. The first represents the generated comments that
        // we've actually inserted. The second represents the index of the
        // existing comment we're looking at.

        let commentsInserted = 0;
        let remainingCommentsToLookAt = autogeneratedCommentsWithKeys.length;

        // Keep looping on our remainingCommentsToLookAt

        for (let index = 0; index < remainingCommentsToLookAt; index++) {
          const comment = autogeneratedCommentsWithKeys[commentsInserted];

          // If !commentsValues[index], then we've reached the end of the array
          // and we'll need to go ahead and insert, remembering to mark it.

          if (!commentsValues[index]) {
            newComments = set(index, comment, newComments);
            commentsInserted++;

            continue;
          }

          // If there is a value, but it's empty, then we can use the slot.

          if (commentsValues[index].comment.trim() === "") {
            newComments = set(index, comment, newComments);
            commentsInserted++;

            continue;
          }

          // Otherwise, it's not empty, so we should bump up our remaining
          // comments counter by one and move forward.

          remainingCommentsToLookAt++;
        }

        return newComments;
      }

      return comments.concat(autogeneratedCommentsWithKeys);
    });

    setHasAutogenerated(true);
    setIsAutogenerating(false);
  }, [question, title]);

  const onChangeComment = useCallback(
    (key: string, comment: string) => [
      setComments((comments) =>
        set(
          comments.findIndex((c) => c.key === key),
          { key, comment },
          comments,
        ),
      ),
    ],
    [],
  );

  const onBlurComment = useCallback(
    () => onCommentsBlur(comments.map(({ comment }) => comment)),
    [comments, onCommentsBlur],
  );

  // Effects

  const commentsRef = useRef<Comment[]>(defaultComments);
  useEffect(() => {
    if (commentsRef.current === comments) return;
    commentsRef.current = comments;
    onCommentsChange(comments.filter(Boolean).map(({ comment }) => comment));
  }, [comments, onCommentsChange]);

  // Final state

  const canAutogenerate = useMemo(
    () => Boolean(title && question),
    [title, question],
  );

  // Render

  return (
    <CommentsListView
      state={{
        comments,
        errors,
        canAutogenerate,
        isAutogenerating,
        hasAutogenerated,
        autogeneratingError,
      }}
      callbacks={{
        onClickAddComment,
        onClickRemoveComment,
        onClickAutogenerate,
        onChangeComment,
        onBlurComment,
      }}
    />
  );
};

export default CommentsList;
